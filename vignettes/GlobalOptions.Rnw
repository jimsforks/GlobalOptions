% \VignetteIndexEntry{Generate global option function}
% \VignetteDepends{GlobalOptions}
% \VignettePackage{GlobalOptions}

\documentclass{article}

\title{Generate global option function}

\author{Zuguang Gu {\tt <z.gu@dkfz.de>}}
\usepackage[margin=1in, a4paper]{geometry}

\usepackage{Sweave}
\usepackage{hyperref}
\begin{document}

\maketitle 

Global option function such as {\tt options} and {\tt par} can provide a way to control 
global settings. Here the {\it GlobalOptions} package can generate a function which takes care of
such global settings.

The most simple use is to generate an option function by {\tt setGlobalOptions}:

<<eval = TRUE, echo = TRUE, include = TRUE>>==
library(GlobalOptions)
foo.options = setGlobalOptions(
    a = 1,
    b = "text"
)
@

The returned value {\tt foo.options} is an option function which can be used to get or set
options:

<<eval = TRUE, echo = TRUE, include = TRUE>>==
foo.options()
foo.options("a")
op = foo.options()
op
foo.options(a = 2, b = "new text")
foo.options()
foo.options(op)
foo.options()
@

{\tt foo.options} generated by {\tt setGlobalOptions} will contain an argument {\tt RESET}
which is used to reset the options to the default:

<<eval = TRUE, echo = TRUE, include = TRUE>>==
foo.options(a = 2, b = "new text")
foo.options(RESET = TRUE)
foo.options()
@

If values for options are set as lists, more close controls can be customized. There are two
basic conditions that are used to check the input option values:

<<eval = TRUE, echo = TRUE, include = TRUE>>==
foo.options = setGlobalOptions(
    a = list(.value = 1,
             .length = c(1, 3),
             .class = "numeric")
)
@

In above code, {\tt .value} is the default value for the option {\tt a}, the length of the value
is controlled by {\tt .length} and the length should be either 1 or 3, and the class of the value should be {\tt numeric}. If the input value does not 
fit the criterion, there will be an error. The value of {\tt .length} or {\tt. class} is a 
vector and the checking will be passed if one of the value fits user's input value.

\begin{Schunk}
\begin{Sinput}
> foo.options(a = 1:2)
\end{Sinput}
\begin{Soutput}
Error in foo.options(a = 1:2) : Length of 'a' should be one of 1, 3
\end{Soutput}
\begin{Sinput}
> foo.options(a = "text")
\end{Sinput}
\begin{Soutput}
Error in foo.options(a = "text") : 
  Class of 'a' should be one of 'numeric'.
\end{Soutput}
\end{Schunk}

User can set the value as read-only and modifying such option will cause an error.

\begin{Schunk}
\begin{Sinput}
> foo.options = setGlobalOptions(
+     a = list(.value = 1,
+              .read.only = TRUE)
+ )
> foo.options(a = 2)
\end{Sinput}
\begin{Soutput}
Error in foo.options(a = 2) : 'a' is a read-only option.
\end{Soutput}
\end{Schunk}

There is also a pre-defined argument {\tt READ.ONLY} exported with {\tt foo.options} which controls whether to return only the read-only options or not.

<<eval = TRUE, echo = TRUE, include = TRUE>>==
foo.options = setGlobalOptions(
    a = list(.value = 1,
             .read.only = TRUE),
    b = 2
)
foo.options()
foo.options(READ.ONLY = TRUE)
foo.options(READ.ONLY = FALSE)
@

Validation of the option values can be set by {\tt .validate}. The value should be a function.
The input of the validation function is the input option value and the function should only return
a logical value.

\begin{Schunk}
\begin{Sinput}
> foo.options = setGlobalOptions(
+     a = list(.value = 1,
+              .validate = function(x) x > 0 && x < 10)
+ )
> foo.options(a = 20)
\end{Sinput}
\begin{Soutput}
Error in foo.options(a = 20) : Your option is invalid.
\end{Soutput}
\end{Schunk}

Filtering on the option values can be set by {\tt .filter}. This is useful when the input 
option value is not valid but users only want to change the value without throwing errors. 
For example, there is an option to control whether to print messages or not and it should be set
to {\tt TRUE} or {\tt FALSE}. Anyway, users may set some other type of values such as {\tt NULL}
or {\tt NA}. In this case, non-{\tt TRUE} values can be converted to logical values inside {\tt .filter}.
Similar as {\tt .validate}, the input value for filter function is the input option value, and it 
should return a filtered option value.

<<eval = TRUE, echo = TRUE, include = TRUE>>==
foo.options = setGlobalOptions(
    verbose = 
        list(.value = TRUE,
             .filter = function(x) {
                 if(is.null(x)) {
                     return(FALSE)
                 } else if(is.na(x)) {
                     return(FALSE)
                 } else {
                     return(x)
                 }
              })
)
foo.options(verbose = FALSE); foo.options("verbose")
foo.options(verbose = NA); foo.options("verbose")
foo.options(verbose = NULL); foo.options("verbose")
@

The input option value can be set as dynamic by setting it as a function. When the option
value is set as a function, it will be executed when querying the option. In the following
example, the {\tt prefix} option corresponds to the prefix of some log messages.

<<eval = TRUE, echo = TRUE, include = TRUE>>==
foo.options = setGlobalOptions(
    prefix = ""
)
foo.options(prefix = function() paste("[", Sys.time(), "] ", sep = " "))
foo.options("prefix")
Sys.sleep(2)
foo.options("prefix")
@

If the value of the option is really a function and users don't want to execute it,
just set {\tt .class} to {\tt function}, then the function will be treated as a simple value.

<<eval = TRUE, echo = TRUE, include = TRUE>>==
foo.options = setGlobalOptions(
    test = list(.value = function(x1, x2) t.test(x1, x2)$p.value,
                .class = "function")
)
foo.options(test = function(x1, x2) cor.test(x1, x2)$p.value)
foo.options("test")
@

The self-defined function ({\it i.e.} value function, validation function or filter function) 
is applied per-option. But if it relies on other option values, there is pre-defined 
variable {\tt OPT} which is a list containing values for all options. In following example,
default value of option {\tt b} is two times of the value of option {\tt a}.

<<eval = TRUE, echo = TRUE, include = TRUE>>==
foo.options = setGlobalOptions(
    a = list(.value = 1),
    b = list(.value = function() 2 * OPT$a)
)
foo.options("b")
@

And in the second example, sign of {\tt b} should be as same as sign of {\tt a}.
\begin{Schunk}
\begin{Sinput}
> foo.options = setGlobalOptions(
+     a = list(.value = 1),
+     b = list(.value = 2,
+              .validate = function(x) {
+                  if(OPT$a > 0) x > 0
+                  else x < 0
+              },
+              .filter = function(x) {
+                  x + OPT$a
+              })
+ )
> foo.options("b")
\end{Sinput}
\begin{Soutput}
[1] 2
\end{Soutput}
\begin{Sinput}
> foo.options(a = 1, b = -1)
\end{Sinput}
\begin{Soutput}
Error in foo.options(a = 1, b = -1) : Your option is invalid.
\end{Soutput}
\end{Schunk}

Global options are stored in a private environment. Each time when generating a option function,
there will be a new environment created. Thus global options will not conflict if they come from
different option functions.

<<eval = TRUE, echo = TRUE, include = TRUE>>==
foo.options1 = setGlobalOptions(
    a = list(.value = 1)
)
foo.options2 = setGlobalOptions(
    a = list(.value = 1)
)
foo.options1(a = 2)
foo.options1("a")
foo.options2("a")
@

The option function generated by {\tt setGlobalOptions} contains three arguments:
{\tt ...}, {\tt RESET} and {\tt READ.ONLY}. If you want to put the option function into a 
package, remember to document all three arguments:

<<eval = TRUE, echo = TRUE, include = TRUE>>==
args(foo.options)
@

The final and the most important thing is the check by {\tt .class}, {\tt .length}, {\tt .validate},
{\tt .filter} will not be applied on default values when calling {\tt setGlobalOptions}.

\end{document}
