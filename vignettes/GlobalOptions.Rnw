% \VignetteIndexEntry{Generate global option function}
% \VignetteDepends{GlobalOptions}
% \VignettePackage{GlobalOptions}
%\VignetteCompiler{knitr}
%\VignetteEngine{knitr::knitr}

\documentclass{article}

\title{Generate global option function}

\author{Zuguang Gu {\tt <z.gu@dkfz.de>}}
\usepackage[margin=1in, a4paper]{geometry}

\usepackage{hyperref}
\begin{document}

\maketitle 

Global option function such as {\tt options} and {\tt par} can provide a way to control 
global settings. Here the {\it GlobalOptions} package can generate a function which takes care of
such global settings.

\section{General usage}

The most simple use is to generate an option function with default values by callling {\tt setGlobalOptions}:

<<eval = TRUE, echo = TRUE>>==
library(GlobalOptions)
foo.options = setGlobalOptions(
    a = 1,
    b = "text"
)
@

The returned value {\tt foo.options} is an option function which can be used to get or set
options:

<<>>==
foo.options()
foo.options("a")
op = foo.options()
op
foo.options(a = 2, b = "new text")
foo.options()
foo.options(op)
foo.options()
@

{\tt foo.options} generated by {\tt setGlobalOptions} will contain an argument {\tt RESET}
which is used to reset the options to the default:

<<>>==
foo.options(a = 2, b = "new text")
foo.options(RESET = TRUE)
foo.options()
@

\section{Advanced usage}

If option values are set as lists, more close controls can be customized. There are two
basic fields that are used to check the input option values:

<<>>==
foo.options = setGlobalOptions(
    a = list(.value = 1,
             .length = c(1, 3),
             .class = "numeric")
)
@

In above code, {\tt .value} is the default value for the option {\tt a}, the length of the value
is controlled by {\tt .length} and the length should be either 1 or 3, and the class of the value should be {\tt numeric}. If the input value does not 
fit the criterion, there will be an error. The value of {\tt .length} or {\tt .class} is a 
vector and the checking will be passed if one of the value fits user's input.

<<error = TRUE, purl = FALSE>>==
foo.options(a = 1:2)
foo.options(a = "text")
@

User can set the value as read-only and modifying such option will cause an error.

<<error = TRUE, purl = FALSE>>==
foo.options = setGlobalOptions(
    a = list(.value = 1,
             .read.only = TRUE)
)
foo.options(a = 2)
@

There is also a pre-defined argument {\tt READ.ONLY} exported with {\tt foo.options} which controls whether to return only the read-only options or not.

<<>>==
foo.options = setGlobalOptions(
    a = list(.value = 1,
             .read.only = TRUE),
    b = 2
)
foo.options()
foo.options(READ.ONLY = TRUE)
foo.options(READ.ONLY = FALSE)
@

Validation of the option values can be controlled by {\tt .validate} field. The value of {\tt .validate} should be a function.
The input of the validation function is the input option value and the function should only return
a logical value.

<<error = TRUE, purl = FALSE>>==
foo.options = setGlobalOptions(
    a = list(.value = 1,
             .validate = function(x) x > 0 && x < 10)
)
foo.options(a = 20)
@

Filtering on the option values can be controlled by {\tt .filter} field. This is useful when the input 
option value is not valid but it is not necessary to throw errors. More proper way is to modify the value silently.
For example, there is an option to control whether to print messages or not and it should be set
to {\tt TRUE} or {\tt FALSE}. However, users may set some other type of values such as {\tt NULL}
or {\tt NA}. In this case, non-{\tt TRUE} values can be converted to logical values by {\tt .filter}.
Similar as {\tt .validate}, the input value for filter function is the input option value, and it 
should return a filtered option value.

<<>>==
foo.options = setGlobalOptions(
    verbose = 
        list(.value = TRUE,
             .filter = function(x) {
                 if(is.null(x)) {
                     return(FALSE)
                 } else if(is.na(x)) {
                     return(FALSE)
                 } else {
                     return(x)
                 }
              })
)
foo.options(verbose = FALSE); foo.options("verbose")
foo.options(verbose = NA); foo.options("verbose")
foo.options(verbose = NULL); foo.options("verbose")
@

The input option value can be set as dynamic by setting it as a function. When the option
value is set as a function, it will be executed when querying the option. In the following
example, the {\tt prefix} option corresponds to the prefix of log messages. The returned option
value is the string after the execution of the input function and the function itself is attached
as an attribute of the returned option value.

<<>>==
foo.options = setGlobalOptions(
    prefix = ""
)
foo.options(prefix = function() paste("[", Sys.time(), "] ", sep = " "))
foo.options("prefix")
Sys.sleep(2)
foo.options("prefix")
@

If the value of the option is really a function and users don't want to execute it,
just set {\tt .class} to contain {\tt function}, then the function will be treated as a simple value.

<<>>==
foo.options = setGlobalOptions(
    test = list(.value = function(x1, x2) t.test(x1, x2)$p.value,
                .class = "function")
)
foo.options(test = function(x1, x2) cor.test(x1, x2)$p.value)
foo.options("test")
@

The self-defined function ({\it i.e.} value function, validation function or filter function) 
is applied per-option. But if it relies on other option values, there is pre-defined 
variable {\tt OPT} which is a list containing values for all options. In following example,
default value of option {\tt b} is two times of the value of option {\tt a}.

<<>>==
foo.options = setGlobalOptions(
    a = list(.value = 1),
    b = list(.value = function() 2 * OPT$a)
)
foo.options("b")
foo.options(a = 2)
foo.options("b")
@

And in the second example, sign of {\tt b} should be as same as sign of {\tt a}.

<<error = TRUE, purl = FALSE>>==
foo.options = setGlobalOptions(
    a = list(.value = 1),
    b = list(.value = 0,
             .validate = function(x) {
                 if(OPT$a > 0) x > 0
                 else x < 0
             },
             .filter = function(x) {
                 x + OPT$a
             })
)
foo.options(b = 1)
foo.options("b")
foo.options(a = 1, b = -1)
@

\section{Features for package development}

Two additional fields may be helpful when developing packages. {\tt .visible} controls whether
options are visible to users. If options names are specified as empty or a vector with length more than one when querying options,
the invisible options will be hidden. The invisible option can only be queried or modified by specifying its single
option name (just like you can only open the door with the correct unique key). This would be helpful if users want to put some secret options while do not want others to access.
Is this case, they can assign names with complex strings like {\tt .\_\_MY\_PRIVATE\_KEY\_\_.} as their secret options and afterwards
they can access it with this special key.

<<>>==
foo.options = setGlobalOptions(
	a = list(.value = 1,
	         .visible = FALSE),
	b = 2
)
foo.options()
foo.options("a")
foo.options(a = 2)
foo.options("a")
@


Another field {\tt .private} controls whether the option is only private to the package. 
If it is set to {\tt TRUE}, the option can only be modified in the same namespace (or top environment)
where the option function is generated. E.g, if you are writing a package named {\tt foo} and generating
an option function {\tt foo.options}, by setting the option with {\tt .private} to {\tt TRUE}, the value for
such options can only be modified inside {\tt foo} package while it is not permitted outside {\tt foo}. At the same time,
private options become read-only options if querying outside {\tt foo} package.


The option function generated by {\tt setGlobalOptions} contains four arguments:
{\tt ...}, {\tt RESET}, {\tt READ.ONLY}. If you want to put the option function into a 
package, remember to document all the three arguments:

<<>>==
args(foo.options)
@

\section{Misc}

The order of checking when setting an option value is {\tt .read.only}, {\tt .private}, 
{\tt .length}, {\tt .class}, {\tt .validate}, {\tt .filter}, {\tt .length}, {\tt .class}.
Note checking on length and class of the option values will be applied again after filtering.

Global options are stored in a private environment. Each time when generating a option function,
there will be a new environment created. Thus global options will not conflict if they come from
different option functions.

<<>>==
foo.options1 = setGlobalOptions(
    a = list(.value = 1)
)
foo.options2 = setGlobalOptions(
    a = list(.value = 1)
)
foo.options1(a = 2)
foo.options1("a")
foo.options2("a")
@

Note the option values can also be set as a list, so for the list containing configurations, 
names of the field is started with a dot {\tt .} to be distinguished from the normal list.


The final and the most important thing is the check by {\tt .class}, {\tt .length}, {\tt .validate},
{\tt .filter} will not be applied on default values when calling {\tt setGlobalOptions} because 
users who design their option functions by {\tt setGlobalOptions} should know whether the default values are valid or not.

\end{document}